## ğŸ“˜ AVL Tree Implementation in C++

This project implements a **self-balancing Binary Search Tree (BST)** known as an **AVL Tree** in **C++**. The AVL Tree maintains the height-balance property by performing automatic rotations during **insertion** and **deletion**, ensuring **O(log n)** time complexity for search, insert, and delete operations.

---

### ğŸ” Key Features

* âœ… **Balanced BST**: Ensures minimal height after every update
* ğŸ”„ **Automatic Rotations**: Handles LL, RR, LR, and RL imbalances
* ğŸ§ª **Comprehensive Testing**: Includes extensive test cases for insertions, deletions, and chain deletions
* ğŸ“š **Modular Code**: Clean class-based structure with encapsulated node and tree logic

---

### ğŸ’¡ What Is an AVL Tree?

An **AVL Tree** (named after Adelson-Velsky and Landis) is a type of binary search tree where the **difference in height** between the left and right subtree of every node (the **balance factor**) is at most **1**. When this condition is violated, the tree performs one of four types of **rotations** to restore balance:

* **LL (Left-Left) Rotation**
* **RR (Right-Right) Rotation**
* **LR (Left-Right) Rotation**
* **RL (Right-Left) Rotation**

---

### âš™ï¸ Usage

You can integrate this AVL Tree in larger projects or use it as a standalone module for learning, testing, or performance analysis.

---
