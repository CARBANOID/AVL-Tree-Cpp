## 📘 AVL Tree Implementation in C++

This project implements a **self-balancing Binary Search Tree (BST)** known as an **AVL Tree** in **C++**. The AVL Tree maintains the height-balance property by performing automatic rotations during **insertion** and **deletion**, ensuring **O(log n)** time complexity for search, insert, and delete operations.

---

### 🔍 Key Features

* ✅ **Balanced BST**: Ensures minimal height after every update
* 🔄 **Automatic Rotations**: Handles LL, RR, LR, and RL imbalances
* 🧪 **Comprehensive Testing**: Includes extensive test cases for insertions, deletions, and chain deletions
* 📚 **Modular Code**: Clean class-based structure with encapsulated node and tree logic

---

### 💡 What Is an AVL Tree?

An **AVL Tree** (named after Adelson-Velsky and Landis) is a type of binary search tree where the **difference in height** between the left and right subtree of every node (the **balance factor**) is at most **1**. When this condition is violated, the tree performs one of four types of **rotations** to restore balance:

* **LL (Left-Left) Rotation**
* **RR (Right-Right) Rotation**
* **LR (Left-Right) Rotation**
* **RL (Right-Left) Rotation**

---

### ⚙️ Usage

You can integrate this AVL Tree in larger projects or use it as a standalone module for learning, testing, or performance analysis.

---
